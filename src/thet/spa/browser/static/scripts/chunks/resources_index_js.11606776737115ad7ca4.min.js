"use strict";
(self["webpackChunkthet_spa"] = self["webpackChunkthet_spa"] || []).push([["resources_index_js"],{

/***/ "./node_modules/@patternslib/dev/webpack/module_federation--dynamic-federation.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@patternslib/dev/webpack/module_federation--dynamic-federation.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ get_container; }
/* harmony export */ });
// Author: Manfred Steyer <manfred.steyer@gmx.net>
// Author: Johannes Raggam <thetetet@gmail.com>

// From:
//   https://github.com/manfredsteyer/plugin-demo.git
//   https://github.com/thet/module-federation-minimaltest.git

/**
 * Load remote module / bundle.
 *
 * Wrapper around webpack runtime API
 *
 * Usage: get_container("bundle-name-xyz")
 *
 * @param {string} remote - the remote global name
 * @returns {Promise<object>} - Federated Module Container
 */
const container_map = {};
let is_default_scope_initialized = false;
async function get_container(remote) {
  const container = window[remote];

  // Do we still need to initialize the remote?
  if (container_map[remote]) {
    return container;
  }

  // Do we still need to initialize the shared scope?
  if (!is_default_scope_initialized) {
    await __webpack_require__.I("default"); // eslint-disable-line no-undef
    is_default_scope_initialized = true;
  }
  await container.init(__webpack_require__.S.default); // eslint-disable-line no-undef

  // Remember that the container has been initialized.
  container_map[remote] = true;
  return container;
}

/***/ }),

/***/ "./node_modules/@patternslib/dev/webpack/module_federation.js":
/*!********************************************************************!*\
  !*** ./node_modules/@patternslib/dev/webpack/module_federation.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MF_NAME_PREFIX: function() { return /* binding */ MF_NAME_PREFIX; },
/* harmony export */   initialize_remote: function() { return /* binding */ initialize_remote; }
/* harmony export */ });
/* harmony import */ var _module_federation_dynamic_federation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module_federation--dynamic-federation */ "./node_modules/@patternslib/dev/webpack/module_federation--dynamic-federation.js");
/**
 * Initialize dynamic module federation.
 */


// Patternslib Module Federation bundle prefix.
// This is used to filter for module federation enabled bundles.
// NOTE: This is also defined in ``webpack.mf.js``.
const MF_NAME_PREFIX = "__patternslib_mf__";
if (typeof window.__patternslib_container_map === "undefined") {
  window.__patternslib_container_map = {};
}
const container_map = window.__patternslib_container_map;
async function initialize_remote({
  remote_name,
  exposed_module = "./main"
}) {
  if (container_map[`${remote_name}-${exposed_module}`]) {
    // already initialized, return.
    return;
  }
  const container = await (0,_module_federation_dynamic_federation__WEBPACK_IMPORTED_MODULE_0__["default"])(remote_name);
  const factory = await container.get(exposed_module);
  const module = factory();
  container_map[`${remote_name}-${exposed_module}`] = true;
  console.debug(`Patternslib Module Federation: Loaded and initialized bundle "${remote_name}".`);
  return module;
}
function document_ready(fn) {
  // see if DOM is already available
  if (document.readyState === "complete" || document.readyState === "interactive") {
    // call on next available tick
    setTimeout(fn, 1);
  } else {
    document.addEventListener("DOMContentLoaded", fn);
  }
}
document_ready(function () {
  // Automatically initialize all Module Federation enabled Patternslib based
  // bundles by filtering for the prefix ``__patternslib_mf__``.
  // Do this on document ready, as this is the time where all MF bundles have
  // been registered in the global namespace.
  const bundles = Object.keys(window).filter(it => it.indexOf(MF_NAME_PREFIX) === 0);
  for (const bundle_name of bundles) {
    // Now load + initialize each bundle.
    initialize_remote({
      remote_name: bundle_name
    });
  }
  document.dispatchEvent(new Event("patternslib__mf--loaded", {
    bubbles: true,
    cancelable: false
  }));
});

/***/ }),

/***/ "./resources/index.js":
/*!****************************!*\
  !*** ./resources/index.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _patternslib_dev_webpack_module_federation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @patternslib/dev/webpack/module_federation */ "./node_modules/@patternslib/dev/webpack/module_federation.js");


// Webpack entry point for module federation.
Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_patternslib_patternslib_src_core_basepattern_js-node_modules_patternslib-e27b89"), __webpack_require__.e("resources_bundle_js")]).then(__webpack_require__.bind(__webpack_require__, /*! ./bundle */ "./resources/bundle.js"));

/***/ })

}]);
//# sourceMappingURL=resources_index_js.11606776737115ad7ca4.min.js.map