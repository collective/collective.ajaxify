{"version":3,"file":"chunks/47943.43cc66f2e34d45a73b0a.min.js","mappings":"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","sources":["webpack://collective.ajaxify/./node_modules/@patternslib/patternslib/src/pat/inject/inject.js","webpack://collective.ajaxify/./resources/bundle.js"],"sourcesContent":["import \"../../core/polyfills\"; // SubmitEvent.submitter for Safari < 15.4 and jsDOM\nimport $ from \"jquery\";\nimport ajax from \"../ajax/ajax\";\nimport dom from \"../../core/dom\";\nimport events from \"../../core/events\";\nimport logging from \"../../core/logging\";\nimport Parser from \"../../core/parser\";\nimport registry from \"../../core/registry\";\nimport create_uuid from \"../../core/uuid\";\nimport utils from \"../../core/utils\";\n\nconst log = logging.getLogger(\"pat.inject\");\n//log.setLevel(logging.Level.DEBUG);\n\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\n\nexport const parser = new Parser(\"inject\");\nparser.addArgument(\"default-selector\");\nparser.addArgument(\"target\");\nparser.addArgument(\"data-type\", \"html\");\nparser.addArgument(\"next-href\");\nparser.addArgument(\"source\");\nparser.addArgument(\"trigger\", \"default\", [\n    \"default\",\n    \"autoload\",\n    \"autoload-visible\",\n    \"idle\",\n]);\nparser.addArgument(\"delay\"); // only used in autoload\nparser.addArgument(\"browser-cache\", \"no-cache\", [\"cache\", \"no-cache\"]); // Cache ajax requests. Pass to pat-ajax.\nparser.addArgument(\"confirm\", \"class\", [\"never\", \"always\", \"form-data\", \"class\"]);\nparser.addArgument(\"confirm-message\", \"Are you sure you want to leave this page?\");\nparser.addArgument(\"loading-class\", \"injecting\"); // Add a class to the target while content is still loading.\nparser.addArgument(\"executing-class\", \"executing\"); // Add a class to the element while content is still loading.\nparser.addArgument(\"executed-class\", \"executed\"); // Add a class to the element when content is loaded.\nparser.addArgument(\"class\"); // Add a class to the injected content.\nparser.addArgument(\"history\", \"none\", [\"none\", \"record\"]);\nparser.addArgument(\"push-marker\");\nparser.addArgument(\"scroll\");\n\n// Note: this should not be here but the parser would bail on unknown\n// parameters and expand/collapsible need to pass the url to us.\nparser.addArgument(\"url\");\n\nconst inject = {\n    name: \"inject\",\n    trigger: \"a.pat-inject, form.pat-inject, .pat-subform.pat-inject\",\n    parser: parser,\n\n    async init($el, opts) {\n        // We need to wait a tick. Modern BasePattern based patterns like\n        // pat-validation do always wait a tick before initializing. The\n        // patterns registry always initializes pat-validation first but since\n        // it is waiting a tick the event handlers are registerd after the ones\n        // from pat-inject. Waiting a tick in pat-inject solves this -\n        // pat-validation's event handlers are initialized first.\n        await utils.timeout(1);\n\n        const el = utils.jqToNode($el);\n\n        const cfgs = this.extractConfig($el, opts);\n        if (cfgs.some((e) => e.history === \"record\") && !(\"pushState\" in history)) {\n            // if the injection shall add a history entry and HTML5 pushState\n            // is missing, then don't initialize the injection.\n            log.warn(\"HTML5 pushState is missing, aborting\");\n            return $el;\n        }\n        $el.data(\"pat-inject\", cfgs);\n\n        if (cfgs[0].nextHref && cfgs[0].nextHref.indexOf(\"#\") === 0) {\n            // In case the next href is an anchor, and it already\n            // exists in the page, we do not activate the injection\n            // but instead just change the anchors href.\n\n            // Note: This is used in only one project for linked fullcalendars,\n            // it's sanity is wonky and we should probably solve it differently.\n            if (el.nodeName === \"A\" && $(cfgs[0].nextHref).length > 0) {\n                log.debug(\n                    \"Skipping as next href is anchor, which already exists\",\n                    cfgs[0].nextHref\n                );\n                // TODO: reconsider how the injection enters exhausted state\n                el.setAttribute(\n                    \"href\",\n                    (window.location.href.split(\"#\")[0] || \"\") + cfgs[0].nextHref\n                );\n                return $el;\n            }\n        }\n        if (cfgs[0].pushMarker) {\n            $(\"body\").on(\"push\", (event, data) => {\n                log.debug(\"received push message: \" + data);\n                if (data == cfgs[0].pushMarker) {\n                    log.debug(\"re-injecting \" + data);\n                    this.onTrigger({ currentTarget: el });\n                }\n            });\n        }\n        if (cfgs[0].idleTrigger) {\n            this._initIdleTrigger($el, cfgs[0].idleTrigger);\n        } else {\n            switch (cfgs[0].trigger) {\n                case \"default\":\n                    for (const cfg of cfgs) {\n                        if (cfg.delay) {\n                            cfg.processDelay = cfg.delay;\n                        }\n                    }\n                    // setup event handlers\n                    if (el?.nodeName === \"FORM\") {\n                        log.debug(\"Initializing form with injection on\", el);\n                        events.add_event_listener(\n                            el,\n                            \"submit\",\n                            \"pat-inject--form-submit\",\n                            (e) => {\n                                if (\n                                    e.submitter?.matches(\n                                        \"[type=submit], button:not([type=button]), [type=image]\"\n                                    )\n                                ) {\n                                    // make sure the submitting button is sent\n                                    // with the form\n                                    ajax.onClickSubmit(e);\n                                }\n                                this.onTrigger(e);\n                            }\n                        );\n                    } else if (el?.matches(\".pat-subform\")) {\n                        log.debug(\"Initializing subform with injection\");\n                    } else {\n                        $el.on(\"click.pat-inject\", this.onTrigger.bind(this));\n                    }\n                    break;\n                case \"autoload\":\n                    if (!cfgs[0].delay) {\n                        this.onTrigger({ currentTarget: el });\n                    } else {\n                        // generate UUID\n                        const uuid = create_uuid();\n                        el.setAttribute(\"data-pat-inject-uuid\", uuid);\n\n                        // function to trigger the autoload and mark as triggered\n                        const delayed_trigger = (uuid_) => {\n                            // Check if the element has been removed from the dom\n                            const still_there = document.querySelector(\n                                `[data-pat-inject-uuid=\"${uuid_}\"]`\n                            );\n                            if (!still_there) {\n                                return false;\n                            }\n\n                            $el.data(\"pat-inject-autoloaded\", true);\n                            this.onTrigger({ currentTarget: el });\n                            // Cleanup again.\n                            still_there.removeAttribute(\"data-pat-inject-uuid\");\n                            return true;\n                        };\n                        window.setTimeout(\n                            delayed_trigger.bind(null, uuid),\n                            cfgs[0].delay\n                        );\n                    }\n                    break;\n                case \"autoload-visible\":\n                    this._initAutoloadVisible($el, cfgs);\n                    break;\n                case \"idle\":\n                    this._initIdleTrigger($el, cfgs[0].delay);\n                    break;\n            }\n        }\n\n        log.debug(\"initialised:\", el);\n        return $el;\n    },\n\n    destroy($el) {\n        $el.off(\".pat-inject\");\n        $el.data(\"pat-inject\", null);\n        return $el;\n    },\n\n    onTrigger(e) {\n        /* Injection has been triggered, either via form submission or a\n         * link has been clicked.\n         */\n\n        // Prevent the original event from doing it's work.\n        // We want an AJAX request instead.\n        e.preventDefault && e.preventDefault();\n\n        const el = e.currentTarget;\n        const $el = $(el);\n        let cfgs = $el.data(\"pat-inject\");\n        if (el.nodeName === \"FORM\" && e.type === \"submit\") {\n            const form = el;\n            const submitter = e.submitter;\n\n            // Do not submit invalid forms, if validation is active.\n            // Works with native form validation and with pat-validation.\n            if (\n                !submitter?.matches(\"[formnovalidate]\") &&\n                !form.matches(\"[novalidate]\") &&\n                form.matches(\":invalid\")\n            ) {\n                log.debug(\"Form is invalid, aborting\");\n                return;\n            }\n\n            const formaction = submitter?.getAttribute(\"formaction\");\n            if (formaction) {\n                const opts = {\n                    url: formaction,\n                };\n\n                // Support custom data-pat-inject on formaction buttons.\n                const cfg_node = submitter.closest(\"[data-pat-inject]\");\n                cfgs = this.extractConfig($(cfg_node), opts);\n            }\n\n            // store the params of the form in the config, to be used by history\n            for (const cfg of cfgs) {\n                cfg.params = $.param($el.serializeArray());\n            }\n        }\n\n        $el.trigger(\"patterns-inject-triggered\");\n        this.execute(cfgs, $el);\n    },\n\n    submitSubform($sub) {\n        /* This method is called from pat-subform\n         */\n        const $el = $($sub[0].closest(\"form\"));\n        const cfgs = $sub.data(\"pat-inject\");\n\n        // store the params of the subform in the config, to be used by history\n        for (const cfg of cfgs) {\n            cfg.params = $.param($sub.serializeArray());\n        }\n\n        try {\n            $el.trigger(\"patterns-inject-triggered\");\n        } catch (e) {\n            log.error(\"patterns-inject-triggered\", e);\n        }\n        this.execute(cfgs, $el);\n    },\n\n    extractConfig($el, options = {}) {\n        const el = utils.jqToNode($el);\n        options = Object.assign({}, options); // copy\n\n        const cfgs = parser.parse($el, options, true);\n        for (const cfg of cfgs) {\n            cfg.$context = $el;\n            // options and cfg have priority, fall back to href/action\n            cfg.url =\n                options.url ||\n                cfg.url ||\n                el?.getAttribute(\"href\") ||\n                el?.getAttribute(\"action\") ||\n                el?.closest(\"form\")?.getAttribute(\"action\") ||\n                \"\";\n\n            // separate selector from url\n            const urlparts = cfg.url.split(\"#\");\n            cfg.url = urlparts[0];\n\n            if (urlparts.length > 2) {\n                log.warn(\"Ignoring additional source ids:\", urlparts.slice(2));\n            }\n\n            if (!cfg.defaultSelector) {\n                // if no selector, check for selector as part of original url\n                cfg.defaultSelector = (urlparts[1] && \"#\" + urlparts[1]) || \"body\";\n            }\n            if (cfg.delay) {\n                try {\n                    cfg.delay = utils.parseTime(cfg.delay);\n                } catch {\n                    log.warn(\"Invalid delay value: \", cfg.delay);\n                    cfg.delay = null;\n                }\n            }\n            cfg.processDelay = 0;\n        }\n        return cfgs;\n    },\n\n    elementIsDirty(m) {\n        /* Check whether the passed in form element contains a value.\n         */\n        const data = $.map(m.find(\":input:not(select)\"), (i) => {\n            const val = $(i).val();\n            return Boolean(val) && val !== $(i).attr(\"placeholder\");\n        });\n        return $.inArray(true, data) !== -1;\n    },\n\n    askForConfirmation(cfgs) {\n        /* If configured to do so, show a confirmation dialog to the user.\n         * This is done before attempting to perform injection.\n         */\n        let should_confirm = false;\n        let message;\n\n        for (const cfg of cfgs) {\n            let _confirm = false;\n            if (cfg.confirm == \"always\") {\n                _confirm = true;\n            } else if (\n                cfg.confirm === \"form-data\" &&\n                cfg.target &&\n                cfg.target !== \"none\"\n            ) {\n                _confirm = this.elementIsDirty(cfg.$target);\n            } else if (cfg.confirm === \"class\" && cfg.target && cfg.target !== \"none\") {\n                _confirm = cfg.$target.hasClass(\"is-dirty\");\n            }\n            if (_confirm) {\n                should_confirm = true;\n                message = cfg.confirmMessage;\n            }\n        }\n        if (should_confirm) {\n            if (!window.confirm(message)) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    ensureTarget(cfg) {\n        /* Make sure that a target element exists and that it's assigned to\n         * cfg.$target.\n         */\n        // make sure target exist\n        if (cfg.target === \"none\") {\n            // special case, we don't want to inject anything\n            return true;\n        }\n        cfg.$target =\n            cfg.$target || (cfg.target === \"self\" ? cfg.$context : $(cfg.target));\n        if (cfg.$target.length === 0) {\n            if (!cfg.target) {\n                log.error(\"Need target selector\", cfg);\n                return false;\n            }\n            cfg.$target = this.createTarget(cfg.target);\n            cfg.$created_target = cfg.$target;\n        }\n        return true;\n    },\n\n    verifySingleConfig(url, cfg) {\n        /* Verify one of potentially multiple configs (i.e. argument lists).\n         *\n         * Extract modifiers such as ::element or ::after.\n         * Ensure that a target element exists.\n         */\n        if (cfg.url !== url) {\n            // in case of multi-injection, all injections need to use\n            // the same url\n            log.error(\"Unsupported different urls for multi-inject\");\n            return false;\n        }\n        // defaults\n        cfg.source = cfg.source || cfg.defaultSelector;\n        cfg.target = cfg.target || cfg.defaultSelector;\n\n        if (!this.extractModifiers(cfg)) {\n            return false;\n        }\n        if (!this.ensureTarget(cfg)) {\n            return false;\n        }\n        this.listenForFormReset(cfg);\n        return true;\n    },\n\n    verifyConfig(cfgs) {\n        /* Verify and post-process all the configurations.\n         * Each \"config\" is an arguments list separated by the &&\n         * combination operator.\n         *\n         * In case of multi-injection, only one URL is allowed, which\n         * should be specified in the first config (i.e. arguments list).\n         *\n         * Verification for each cfg in the array needs to succeed.\n         */\n        return cfgs.every((cfg) => this.verifySingleConfig(cfgs[0].url, cfg));\n    },\n\n    listenForFormReset(cfg) {\n        /* if pat-inject is used to populate target in some form and when\n         * Cancel button is pressed (this triggers reset event on the\n         * form) you would expect to populate with initial placeholder\n         */\n        if (cfg.target === \"none\") {\n            // Special case, we don't want to display any return value.\n            return;\n        }\n        const $form = cfg.$target.parents(\"form\");\n        if ($form.length !== 0 && cfg.$target.data(\"initial-value\") === undefined) {\n            cfg.$target.data(\"initial-value\", cfg.$target.html());\n            $form.on(\"reset\", () => {\n                cfg.$target.html(cfg.$target.data(\"initial-value\"));\n            });\n        }\n    },\n\n    extractModifiers(cfg) {\n        /* The user can add modifiers to the source and target arguments.\n         * Modifiers such as ::element, ::before and ::after.\n         * We identifiy and extract these modifiers here.\n         */\n        const source_re = /^(.*?)(::element)?$/;\n        const target_re = /^(.*?)(::element)?(::after|::before)?$/;\n        const source_match = source_re.exec(cfg.source);\n        const target_match = target_re.exec(cfg.target);\n\n        cfg.source = source_match[1];\n        cfg.sourceMod = source_match[2] ? \"element\" : \"content\";\n        cfg.target = target_match[1];\n        const targetMod = target_match[2] ? \"element\" : \"content\";\n        const targetPosition = (target_match[3] || \"::\").slice(2); // position relative to target\n\n        if (cfg.loadingClass) {\n            cfg.loadingClass += \" \" + cfg.loadingClass + \"-\" + targetMod;\n            if (targetPosition && cfg.loadingClass) {\n                cfg.loadingClass += \" \" + cfg.loadingClass + \"-\" + targetPosition;\n            }\n        }\n        cfg.action = targetMod + targetPosition;\n        // Once we start detecting illegal combinations, we'll\n        // return false in case of error\n        return true;\n    },\n\n    createTarget(selector) {\n        /* create a target that matches the selector\n         *\n         * Note: so far we only support #target and create a div with that id\n         * appended to the body.\n         */\n        if (selector.slice(0, 1) !== \"#\") {\n            log.error(\"only id supported for non-existing target\");\n            return null;\n        }\n        const $target = $(\"<div />\").attr({ id: selector.slice(1) });\n        $(\"body\").append($target);\n        return $target;\n    },\n\n    _performInjection(target, $el, $sources, cfg, trigger, $title) {\n        /* Called after the XHR has succeeded and we have a new $sources\n         * element to inject.\n         */\n        const wrapper = document.createElement(\"template\");\n        if ($sources.length > 0) {\n            const method = cfg.sourceMod === \"content\" ? \"innerHTML\" : \"outerHTML\";\n            // There might be multiple sources, so we need to loop over them.\n            // Access them with \"innerHTML\" or \"outerHTML\" depending on the sourceMod.\n            const sources_string = [...$sources].map(source => source[method]).join(\"\\n\");\n            wrapper.innerHTML = sources_string;\n\n            for (const img of wrapper.content.querySelectorAll(\"img\")) {\n                events.add_event_listener(\n                    img,\n                    \"load\",\n                    \"inject_img_load\",\n                    (e) => {\n                        $(e.currentTarget).trigger(\"pat-inject-content-loaded\");\n                    },\n                    { once: true }\n                );\n            }\n        }\n\n        // Copy, because after insertion wrapper.children is empty.\n        const source_nodes = [...wrapper.content.childNodes];\n\n        // Now the injection actually happens.\n        if (this._inject(trigger, source_nodes, target, cfg)) {\n            // Update history\n            this._update_history(cfg, trigger, $title);\n            // Post-injection\n            this._afterInjection($el, cfg.$created_target || $(source_nodes), cfg);\n        }\n    },\n\n    _update_history(cfg, trigger, $title) {\n        // History support. if subform is submitted, append form params\n        if (cfg.history !== \"record\" || !history?.pushState) {\n            return;\n        }\n        let url = cfg.url;\n        if (cfg.params) {\n            const glue = url.indexOf(\"?\") > -1 ? \"&\" : \"?\";\n            url = `${url}${glue}${cfg.params}`;\n        }\n        history.pushState({ url: url }, \"\", url);\n        // Also inject title element if we have one\n        if ($title?.length) {\n            const title_el = document.querySelector(\"title\");\n            if (title_el) {\n                this._inject(trigger, $title, title_el, {\n                    action: \"element\",\n                });\n            }\n        }\n    },\n\n    _afterInjection($el, $injected, cfg) {\n        /* Set a class on the injected elements and fire the\n         * patterns-injected event.\n         */\n        const el = utils.jqToNode($el);\n        $injected\n            .filter((idx, el_) => {\n                return el_.nodeType !== TEXT_NODE;\n            })\n            .data(\"pat-injected\", { origin: cfg.url });\n\n        if ($injected.length === 1 && $injected[0].nodeType == TEXT_NODE) {\n            // Only one element injected, and it was a text node.\n            // So we trigger \"patterns-injected\" on the parent.\n            // The event handler should check whether the\n            // injected element and the triggered element are\n            // the same.\n            $injected.parent().trigger(\"patterns-injected\", [cfg, el, $injected[0]]);\n        } else {\n            $injected.each((idx, el_) => {\n                // patterns-injected event will be triggered for each injected (non-text) element.\n                if (el_.nodeType !== TEXT_NODE) {\n                    $(el_)\n                        .addClass(cfg[\"class\"])\n                        .trigger(\"patterns-injected\", [cfg, el, el_]);\n                }\n            });\n        }\n\n        if (cfg.scroll && cfg.scroll !== \"none\") {\n            // Get the scroll target for\n            // 1) finding the scroll container\n            // 2) getting the element to scroll to (if not \"top\")\n            const scroll_target = [\"top\", \"target\"].includes(cfg.scroll)\n                ? cfg.$target[0]\n                : dom.querySelectorAllAndMe($injected[0], cfg.scroll);\n\n            const scroll_container = dom.find_scroll_container(\n                scroll_target,\n                null,\n                window\n            );\n\n            if (cfg.scroll === \"top\") {\n                dom.scroll_to_top(scroll_container);\n            } else if (scroll_target) {\n                dom.scroll_to_element(scroll_target, scroll_container);\n            }\n        }\n\n        el.dispatchEvent(\n            new Event(\"pat-inject-success\", { bubbles: true, cancelable: true })\n        );\n    },\n\n    async _onInjectSuccess($el, cfgs, ev) {\n        let data = ev?.jqxhr?.responseText;\n        if (!data) {\n            log.warn(\"No response content, aborting\", ev);\n            return;\n        }\n        if (cfgs[0].source === \"none\") {\n            // Special case, we want to call something, but we don't want to inject anything\n            data = \"\";\n        }\n        const sources$ = await this.callTypeHandler(cfgs[0].dataType, \"sources\", $el, [\n            cfgs,\n            data,\n            ev,\n        ]);\n        /* pick the title source for dedicated handling later\n          Title - if present - is always appended at the end. */\n        let $title;\n        if (\n            sources$ &&\n            sources$[sources$.length - 1] &&\n            sources$[sources$.length - 1][0] &&\n            sources$[sources$.length - 1][0].nodeName === \"TITLE\"\n        ) {\n            $title = sources$[sources$.length - 1];\n        }\n        cfgs.forEach((cfg, idx1) => {\n            const perform_inject = () => {\n                if (cfg.target !== \"none\") {\n                    for (const target of cfg.$target) {\n                        this._performInjection(\n                            target,\n                            $el,\n                            sources$[idx1],\n                            cfg,\n                            ev.target,\n                            $title\n                        );\n                    }\n                }\n            };\n            if (cfg.processDelay) {\n                setTimeout(() => perform_inject(), cfg.processDelay);\n            } else {\n                perform_inject();\n            }\n        });\n        if (cfgs[0].nextHref && $el.is(\"a\")) {\n            // In case next-href is specified the anchor's href will\n            // be set to it after the injection is triggered.\n            $el.attr({ href: cfgs[0].nextHref.replace(/&amp;/g, \"&\") });\n            this.destroy($el);\n        }\n        $el.off(\"pat-ajax-success.pat-inject\");\n        $el.off(\"pat-ajax-error.pat-inject\");\n    },\n\n    async _onInjectError($el, cfgs, event) {\n        let explanation = \"\";\n        const status = event.jqxhr.status;\n        const timestamp = new Date();\n        if (status % 100 == 4) {\n            explanation =\n                \"Sorry! We couldn't find the page to load. Please make a screenshot and send it to support. Thank you!\";\n        } else if (status % 100 == 5) {\n            explanation =\n                \"I am very sorry! There was an error at the server. Please make a screenshot and contact support. Thank you!\";\n        } else if (status == 0) {\n            explanation =\n                \"It seems, the server is down. Please make a screenshot and contact support. Thank you!\";\n        }\n\n        let error_page;\n        let error_page_fragment;\n        const url_params = new URLSearchParams(window.location.search);\n        if (url_params.get(\"pat-inject-errorhandler.off\") === null) {\n            // Prepare a error page to be injected into the document.\n\n            // Try to get a suitable error message from pre-configured error pages.\n            const error_page_url = document\n                ?.querySelector(`meta[name^=pat-inject-status-${status}]`)\n                ?.getAttribute(\"content\", false);\n            error_page_fragment = error_page_url?.split(\"#\")[1];\n            error_page_fragment = error_page_fragment ? `#${error_page_fragment}` : null;\n\n            if (error_page_fragment) {\n                error_page = document.createElement(\"html\");\n                error_page.innerHTML = event.jqxhr.responseText;\n                error_page = error_page.querySelector(error_page_fragment);\n            }\n\n            if (!error_page && error_page_url) {\n                try {\n                    const error_page_response = await fetch(error_page_url, {\n                        method: \"GET\",\n                    });\n                    error_page = document.createElement(\"html\");\n                    error_page.innerHTML = await error_page_response.text();\n                    error_page = error_page.querySelector(error_page_fragment || \"body\");\n                } catch {\n                    // fall back to standard error message and ignore.\n                }\n            }\n        }\n\n        // clean up\n        for (const cfg of cfgs) {\n            if (\"$created_target\" in cfg) {\n                cfg.$created_target.remove();\n            }\n            cfg.$target.removeClass(cfg.loadingClass);\n            $el.removeClass(cfg.executingClass);\n        }\n        $el.off(\"pat-ajax-success.pat-inject\");\n        $el.off(\"pat-ajax-error.pat-inject\");\n\n        if (error_page) {\n            const error_zone = document.querySelector(error_page_fragment || \"body\");\n            error_zone.innerHTML = error_page.innerHTML;\n            registry.scan(error_zone); // initialize any patterns in error page\n        } else {\n            const msg_attr = `${explanation} Status is ${status} ${event.jqxhr.statusText}, time was ${timestamp}. You can click to close this.`;\n            $(\"body\").attr(\"data-error-message\", msg_attr);\n            $(\"body\").on(\"click\", () => {\n                $(\"body\").removeAttr(\"data-error-message\");\n                window.location.href = window.location.href; // reload\n            });\n        }\n    },\n\n    execute(cfgs, $el) {\n        /* Actually execute the injection.\n         *\n         * Either by making an ajax request or by spoofing an ajax\n         * request when the content is readily available in the current page.\n         */\n        const el = utils.jqToNode($el);\n        // get a kinda deep copy, we scribble on it\n        cfgs = cfgs.map((cfg) => $.extend({}, cfg));\n        if (!this.verifyConfig(cfgs)) {\n            return;\n        }\n        if (!this.askForConfirmation(cfgs)) {\n            return;\n        }\n        if ($el.data(\"pat-inject-triggered\")) {\n            // Prevent double triggers;\n            return;\n        }\n        $el.data(\"pat-inject-triggered\", true);\n\n        for (const cfg of cfgs) {\n            // Add a execute class on the pat-inject element.\n            if (cfg?.executingClass) {\n                el.classList.add(cfg.executingClass);\n            }\n            // Add a loading class to the target.\n            // Can be used for loading-spinners.\n            if (cfg?.loadingClass && cfg?.target !== \"none\") {\n                cfg.$target.addClass(cfg.loadingClass);\n            }\n        }\n\n        $el.on(\"pat-ajax-success.pat-inject\", async (e) => {\n            this._onInjectSuccess($el, cfgs, e);\n\n            // Wait for the next tick to ensure that the close-panel listener\n            // is called before this one, even for non-async local injects.\n            await utils.timeout(1);\n            // Remove the close-panel event listener.\n            events.remove_event_listener(el, \"pat-inject--close-panel\");\n            // Only close the panel if a close-panel event was catched previously.\n            if (do_close_panel) {\n                do_close_panel = false;\n                // Re-trigger close-panel event if it was caught while injection was in progress.\n                el.dispatchEvent(\n                    new Event(\"close-panel\", { bubbles: true, cancelable: true })\n                );\n            }\n        });\n        $el.on(\"pat-ajax-error.pat-inject\", this._onInjectError.bind(this, $el, cfgs));\n        $el.on(\"pat-ajax-success.pat-inject pat-ajax-error.pat-inject\", () =>\n            $el.removeData(\"pat-inject-triggered\")\n        );\n\n        // Prevent closing the panel while injection is in progress.\n        let do_close_panel = false;\n        events.add_event_listener(el, \"close-panel\", \"pat-inject--close-panel\", (e) => {\n            e.stopPropagation();\n            e.stopImmediatePropagation();\n            do_close_panel = true;\n        });\n\n        if (cfgs[0].url.length) {\n            ajax.request($el, {\n                \"url\": cfgs[0].url,\n                \"browser-cache\": cfgs[0].browserCache,\n            });\n        } else {\n            // If there is no url specified, then content is being fetched\n            // from the same page.\n            // No need to do an ajax request for this, so we spoof the ajax\n            // event.\n            $el.trigger({\n                type: \"pat-ajax-success\",\n                jqxhr: {\n                    responseText: $(\"body\").html(),\n                },\n            });\n        }\n    },\n\n    _inject(trigger, source_nodes, target, cfg) {\n        if (cfg.source === \"none\") {\n            // Special case. Clear the target after ajax call.\n            target.replaceWith(\"\");\n            return true;\n        }\n        if (source_nodes.length === 0) {\n            log.warn(\"Aborting injection, source not found:\", source_nodes);\n            $(trigger).trigger(\"pat-inject-missingSource\", {\n                url: cfg.url,\n                selector: cfg.source,\n            });\n            return false;\n        }\n        if (cfg.target === \"none\") {\n            // Special case. Don't do anything, we don't want any result\n            return true;\n        }\n        if (!target) {\n            log.warn(\"Aborting injection, target not found:\", target);\n            $(trigger).trigger(\"pat-inject-missingTarget\", {\n                selector: cfg.target,\n            });\n            return false;\n        }\n\n        // cfg.action to DOM method mapping\n        const method = {\n            content: \"replaceChildren\",\n            contentafter: \"append\",\n            contentbefore: \"prepend\",\n            element: \"replaceWith\",\n            elementafter: \"after\",\n            elementbefore: \"before\",\n        }[cfg.action];\n\n        // Inject the content HERE!\n        target[method](...source_nodes);\n\n        return true;\n    },\n\n    _sourcesFromHtml(html, url, sources) {\n        const $html = this._parseRawHtml(html, url);\n        return sources.map((source) => {\n            if (source === \"body\") {\n                source = \"#__original_body\";\n            }\n            if (source === \"none\") {\n                return $(\"<!-- -->\");\n            }\n            const $source = $html.find(source);\n\n            if ($source.length === 0) {\n                if (source != \"title\") {\n                    log.warn(\"No source elements for selector:\", source, $html);\n                }\n            }\n\n            $source.find('a[href^=\"#\"]').each((idx, el_) => {\n                const href = el_.getAttribute(\"href\");\n                if (href.indexOf(\"#{1}\") !== -1) {\n                    // We ignore hrefs containing #{1} because they're not\n                    // valid and only applicable in the context of\n                    // pat-clone.\n                    return;\n                }\n                // Skip in-document links pointing to an id that is inside\n                // this fragment.\n                if (href.length === 1) {\n                    // Special case for top-of-page links\n                    el_.href = url;\n                } else if (!$source.find(href).length) {\n                    el_.href = url + href;\n                }\n            });\n            return $source;\n        });\n    },\n\n    _rebaseAttrs: {\n        a: \"href\",\n        form: \"action\",\n        img: \"src\",\n        object: \"data\",\n        source: \"src\",\n        video: \"src\",\n    },\n\n    _rebaseOptions: {\n        \"calendar\": [\"url\", \"event-sources\"],\n        \"collapsible\": [\"load-content\"],\n        \"date-picker\": [\"i18n\"],\n        \"datetime-picker\": [\"i18n\"],\n        \"inject\": [\"url\"],\n    },\n\n    _rebaseURL(base, url) {\n        if (url.indexOf(\"://\") !== -1 || url[0] === \"/\" || url.indexOf(\"data:\") === 0) {\n            return url;\n        }\n        base = new URL(base, window.location).href; // If base is relative make it absolute.\n        return base.slice(0, base.lastIndexOf(\"/\") + 1) + url;\n    },\n\n    _rebaseHTML(base, html) {\n        if (html === \"\") {\n            // Special case, source is none\n            return \"\";\n        }\n\n        // Parse the html string into a DOM tree.\n        const page = document.createElement(\"div\");\n        page.innerHTML = html;\n\n        // Create efficient selector for any tag with it's corresponding\n        // attribute from _rebaseAttrs. Note: the current data structure allows\n        // only for one attribute to be rebased per tag.\n        const rebase_selector = Object.entries(this._rebaseAttrs)\n            .map(([tag, attr]) => `${tag}[${attr}]`)\n            .join(\", \");\n        for (const el_ of page.querySelectorAll(rebase_selector)) {\n            const attr = this._rebaseAttrs[el_.nodeName.toLowerCase()];\n            let value = el_.getAttribute(attr);\n\n            if (\n                value &&\n                value.slice(0, 2) !== \"@@\" &&\n                value[0] !== \"#\" &&\n                value.slice(0, 7) !== \"mailto:\" &&\n                value.slice(0, 4) !== \"tel:\" &&\n                value.slice(0, 4) !== \"fax:\" &&\n                value.slice(0, 7) !== \"callto:\" &&\n                value.slice(0, 10) !== \"ts3server:\" &&\n                value.slice(0, 6) !== \"teams:\" &&\n                value.slice(0, 11) !== \"javascript:\"\n            ) {\n                value = this._rebaseURL(base, value);\n                el_.setAttribute(attr, value);\n            }\n        }\n\n        for (const [pattern_name, opts] of Object.entries(this._rebaseOptions)) {\n            for (const el_ of dom.querySelectorAllAndMe(\n                page,\n                `[data-pat-${pattern_name}]`\n            )) {\n                const pattern = registry.patterns?.[pattern_name];\n                const pattern_parser = pattern?.parser;\n                if (!pattern_parser) {\n                    continue;\n                }\n                // parse: no default options, possibly multiple configs, no grouping.\n                const options = pattern_parser.parse(el_, {}, true, false, false);\n                let changed = false;\n                for (const config of options) {\n                    for (const opt of opts) {\n                        const val = config[opt];\n                        if (!val) {\n                            continue;\n                        }\n                        changed = true;\n                        if (Array.isArray(val)) {\n                            config[opt] = val.map((it) => this._rebaseURL(base, it));\n                        } else {\n                            config[opt] = this._rebaseURL(base, val);\n                        }\n                    }\n                }\n                if (changed) {\n                    el_.setAttribute(\n                        `data-pat-${pattern_name}`,\n                        JSON.stringify(options.length === 1 ? options[0] : options)\n                    );\n                }\n            }\n        }\n\n        return page.innerHTML.trim();\n    },\n\n    _parseRawHtml(html, url = \"\") {\n        // remove script tags and head and replace body by a div\n        const title = html.match(/\\<title\\>(.*)\\<\\/title\\>/);\n        let clean_html = html\n            .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, \"\")\n            .replace(/<head\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/head>/gi, \"\")\n            .replace(/<html([^>]*?)>/gi, \"\")\n            .replace(/<\\/html([^>]*?)>/gi, \"\")\n            .replace(/<body([^>]*?)>/gi, '<div id=\"__original_body\">')\n            .replace(/<\\/body([^>]*?)>/gi, \"</div>\");\n\n        if (title && title.length == 2) {\n            clean_html = title[0] + clean_html;\n        }\n        try {\n            clean_html = this._rebaseHTML(url, clean_html);\n        } catch (e) {\n            log.error(\"Error rebasing urls\", e);\n        }\n        const $html = $(\"<div/>\").html(clean_html);\n        if ($html.children().length === 0) {\n            log.warn(\"Parsing html resulted in empty jquery object:\", clean_html);\n        }\n        return $html;\n    },\n\n    _initAutoloadVisible($el, cfgs) {\n        if ($el.data(\"pat-inject-autoloaded\")) {\n            // ignore executed autoloads\n            return false;\n        }\n\n        const el = utils.jqToNode($el);\n\n        // delay: default is 200ms to allow scrolling over and past autoload-visible elements without loading them.\n        const delay = cfgs[0].delay || 200;\n        log.debug(`Delay time: ${delay}`);\n\n        // function to trigger the autoload and mark as triggered\n        const trigger = (event) => {\n            if ($el.data(\"pat-inject-autoloaded\")) {\n                log.debug(`autoload-visible trigger skipped ${el}`);\n                return false;\n            }\n            $el.data(\"pat-inject-autoloaded\", true);\n            this.onTrigger({ currentTarget: el });\n            event && event.preventDefault();\n            log.debug(`autoload-visible trigger run ${el}`);\n            return true;\n        };\n\n        // Config see: https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n        const intersection_observer_config = {\n            threshold: 0, // If even one pixel is visible, the callback will be run.\n            root: null, // Root is browser viewport. If the element is visible to the user, the callback will be run.\n            margin: \"0px\", // No margins. The element is not preloaded.\n        };\n\n        let timeout_id = null;\n        const observer = new IntersectionObserver((entries) => {\n            for (const entry of entries) {\n                if (entry.isIntersecting) {\n                    // Run the callback after 200ms to prevent loading all\n                    // visible elements when scrolling over.\n                    timeout_id = window.setTimeout(() => {\n                        observer.disconnect(); // Stop observing loaded elements.\n                        trigger();\n                    }, delay);\n                    log.debug(`autoload-visible intersecting ${el}`);\n                } else {\n                    window.clearTimeout(timeout_id);\n                    log.debug(`autoload-visible not intersecting ${el}`);\n                }\n            }\n        }, intersection_observer_config);\n        observer.observe(el);\n    },\n\n    _initIdleTrigger($el, delay) {\n        // TODO: handle item removed from DOM\n        const timeout = parseInt(delay, 10);\n        let timer;\n\n        const el = utils.jqToNode($el);\n\n        const onTimeout = () => {\n            this.onTrigger({ currentTarget: el });\n            unsub();\n            clearTimeout(timer);\n        };\n\n        const onInteraction = utils.debounce(() => {\n            if (!document.body.contains(el)) {\n                unsub();\n                return;\n            }\n            clearTimeout(timer);\n            timer = setTimeout(onTimeout, timeout);\n        }, timeout);\n\n        const unsub = () => {\n            for (const event of [\"scroll\", \"resize\"]) {\n                window.removeEventListener(event, onInteraction);\n            }\n            for (const event of [\n                \"click\",\n                \"keypress\",\n                \"keyup\",\n                \"mousemove\",\n                \"touchstart\",\n                \"touchend\",\n            ]) {\n                document.removeEventListener(event, onInteraction);\n            }\n        };\n\n        onInteraction();\n\n        for (const event of [\"scroll\", \"resize\"]) {\n            window.addEventListener(event, onInteraction);\n        }\n        for (const event of [\n            \"click\",\n            \"keypress\",\n            \"keyup\",\n            \"mousemove\",\n            \"touchstart\",\n            \"touchend\",\n        ]) {\n            document.addEventListener(event, onInteraction);\n        }\n    },\n\n    registerTypeHandler(type, handler) {\n        this.handlers[type] = handler;\n    },\n\n    async callTypeHandler(type, fn, context, params) {\n        type = type || \"html\";\n        if (this.handlers[type] && $.isFunction(this.handlers[type][fn])) {\n            return await this.handlers[type][fn].bind(this)(...params);\n        } else {\n            return null;\n        }\n    },\n\n    handlers: {\n        html: {\n            sources(cfgs, data) {\n                const sources = cfgs.map((cfg) => cfg.source);\n                sources.push(\"title\");\n                const result = this._sourcesFromHtml(data, cfgs[0].url, sources);\n                return result;\n            },\n        },\n    },\n};\n\n$(document).on(\"patterns-injected.inject\", async (ev, cfg, trigger, injected) => {\n    /* Listen for the patterns-injected event.\n     *\n     * Remove the \"loading-class\" classes from all injection targets and\n     * then scan the injected content for new patterns.\n     */\n    if (cfg?.skipPatInjectHandler) {\n        // Allow skipping this handler but still have other handlers in other\n        // patterns listen to ``patterns-injected``.\n        return;\n    }\n    if (cfg) {\n        cfg.$target.removeClass(cfg.loadingClass);\n        // Remove the executing class, add the executed class to the element with pat.inject on it.\n        $(trigger).removeClass(cfg.executingClass).addClass(cfg.executedClass);\n    }\n    if (injected.nodeType !== TEXT_NODE && injected.nodeType !== COMMENT_NODE) {\n        registry.scan(injected, null, { type: \"injection\", element: trigger });\n        $(injected).trigger(\"patterns-injected-scanned\");\n\n        await utils.timeout(10); // Wait a bit before dispatching next event.\n        injected.dispatchEvent(\n            new CustomEvent(\"patterns-injected-delayed\", {\n                bubbles: true,\n                cancelable: true,\n                detail: {\n                    injected: injected,\n                },\n            })\n        );\n    }\n});\n\n$(window).on(\"popstate\", (event) => {\n    // popstate also triggers on traditional anchors\n    if (!event.originalEvent.state && \"replaceState\" in history) {\n        try {\n            history.replaceState(\"anchor\", \"\", document.location.href);\n        } catch (e) {\n            log.debug(e);\n        }\n        return;\n    }\n    // Not only change the URL, also reload the page.\n    window.location.reload();\n});\n\n// this entry ensures that the initally loaded page can be reached with\n// the back button\nif (\"replaceState\" in history) {\n    try {\n        history.replaceState(\"pageload\", \"\", document.location.href);\n    } catch (e) {\n        log.debug(e);\n    }\n}\n\nregistry.register(inject);\nexport default inject;\n","import registry from \"@patternslib/patternslib/src/core/registry\";\nimport inject from \"@patternslib/patternslib/src/pat/inject/inject\";\n\n\ndebugger;\n// Add a new trigger for the inject pattern.\ninject.trigger =\n    // All anchors with the pat-inject class.\n    `a.pat-inject`\n    // All anchors within `.pat-inject` from the same domain.\n    + `,.pat-inject a[href^=\"${window.location.origin}\"]`\n    // Except files.\n    + `:not([href*=\"@@download\"])`\n    + `:not([href$=zip])`\n    + `:not([href$=pdf])`\n    + `:not([href$=mp3])`\n    + `:not([href$=wav])`\n    + `:not([href$=jpg])`\n    + `:not([href$=webp])`\n    + `:not([href$=png])`\n    + `:not([href$=txt])`\n    // Don't inject dropdown \"buttons\"\n    + `:not(.dropdown-toggle)`\n    // Don't inject on the autotoc tab headings.\n    + `:not([id^=\"autotoc\"])`\n    // Don't handle explicitly set pat-inject elements.\n    + `:not(.pat-inject)`\n    // Stop global injection when explicitly asked. You can still explicitly\n    // set pat-inject on these elements.\n    + `:not(.stop-pattern)`\n;\n\n\nregistry.init();\n\n\n// UPDATE 2025-10-15: When this bundle is registered as MF master, inject is registered\n// while DOM scanning hasn't been done yet. No need to re-scan.\n\n// Re-scan the DOM for our modified inject pattern.\n// Scanning might have been done at a previous `registry.init` call from another\n// MF bundle, so we need to re-scan for our modified trigger.\n// TODO: Add a hook to modify the trigger before the first scan?\n//registry.scan(document.body, [\"inject\"]);\n"],"names":["log","logging","getLogger","parser","Parser","addArgument","inject","name","trigger","init","$el","opts","utils","timeout","el","jqToNode","cfgs","this","extractConfig","some","e","history","warn","data","nextHref","indexOf","nodeName","$","length","debug","setAttribute","window","location","href","split","pushMarker","on","event","onTrigger","currentTarget","idleTrigger","_initIdleTrigger","cfg","delay","processDelay","events","add_event_listener","submitter","matches","ajax","onClickSubmit","bind","uuid","create_uuid","delayed_trigger","uuid_","still_there","document","querySelector","removeAttribute","setTimeout","_initAutoloadVisible","destroy","off","preventDefault","type","form","formaction","getAttribute","url","cfg_node","closest","params","serializeArray","execute","submitSubform","$sub","error","options","Object","assign","parse","$context","urlparts","slice","defaultSelector","parseTime","elementIsDirty","m","find","i","val","Boolean","attr","askForConfirmation","message","should_confirm","_confirm","confirm","target","$target","hasClass","confirmMessage","ensureTarget","createTarget","$created_target","verifySingleConfig","source","extractModifiers","listenForFormReset","verifyConfig","every","$form","parents","undefined","html","source_match","exec","target_match","sourceMod","targetMod","targetPosition","loadingClass","action","selector","id","append","_performInjection","$sources","$title","wrapper","createElement","method","sources_string","map","join","innerHTML","img","content","querySelectorAll","once","source_nodes","childNodes","_inject","_update_history","_afterInjection","pushState","glue","title_el","$injected","filter","idx","el_","nodeType","origin","parent","each","addClass","scroll","scroll_target","includes","dom","querySelectorAllAndMe","scroll_container","find_scroll_container","scroll_to_top","scroll_to_element","dispatchEvent","Event","bubbles","cancelable","_onInjectSuccess","ev","jqxhr","responseText","sources$","callTypeHandler","dataType","forEach","idx1","perform_inject","is","replace","_onInjectError","explanation","status","timestamp","Date","error_page","error_page_fragment","URLSearchParams","search","get","error_page_url","error_page_response","fetch","text","remove","removeClass","executingClass","error_zone","registry","scan","msg_attr","statusText","removeAttr","classList","add","async","remove_event_listener","do_close_panel","removeData","stopPropagation","stopImmediatePropagation","request","browserCache","replaceWith","contentafter","contentbefore","element","elementafter","elementbefore","_sourcesFromHtml","sources","$html","_parseRawHtml","$source","_rebaseAttrs","a","object","video","_rebaseOptions","_rebaseURL","base","URL","lastIndexOf","_rebaseHTML","page","rebase_selector","entries","tag","toLowerCase","value","pattern_name","pattern","patterns","pattern_parser","changed","config","opt","Array","isArray","it","JSON","stringify","trim","title","match","clean_html","children","timeout_id","observer","IntersectionObserver","entry","isIntersecting","disconnect","clearTimeout","threshold","root","margin","observe","parseInt","timer","onTimeout","unsub","onInteraction","debounce","body","contains","removeEventListener","addEventListener","registerTypeHandler","handler","handlers","fn","context","push","injected","skipPatInjectHandler","executedClass","CustomEvent","detail","originalEvent","state","reload","replaceState","register"],"sourceRoot":""}